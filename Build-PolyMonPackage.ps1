<#
.SYNOPSIS
    Assembles a PolyMon installer package from build output.

.DESCRIPTION
    Collects Manager files, Executive files, monitor DLLs, SQL scripts, and
    installer scripts into a clean PolyMonInstall staging folder.
    Optionally builds the solution first and/or ZIPs the result.

.PARAMETER Build
    Build the solution (Release config) before packaging.

.PARAMETER Zip
    Create a ZIP archive of the staging folder.

.PARAMETER OutputPath
    Where to create the PolyMonInstall folder. Defaults to repo root.

.EXAMPLE
    .\Build-PolyMonPackage.ps1 -Build -Zip
#>
[CmdletBinding()]
param(
    [switch]$Build,
    [switch]$Zip,
    [string]$OutputPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# --- Paths ---
$RepoRoot = $PSScriptRoot
if (-not $OutputPath) { $OutputPath = $RepoRoot }

$SolutionFile  = Join-Path $RepoRoot 'PolyMon(CodePlex).sln'
$ManagerBin    = Join-Path $RepoRoot 'PolyMonManager\bin'
$ExecutiveBin  = Join-Path $RepoRoot 'PolyMonExecutive\bin'
$MonitorsDir   = Join-Path $ManagerBin 'Monitors'
$SqlCreate     = Join-Path $RepoRoot 'PolymonSQL\Create Scripts'
$SqlUpdate     = Join-Path $RepoRoot 'PolymonSQL\Update Scripts'

$StagingRoot   = Join-Path $OutputPath 'PolyMonInstall'
$StageManager  = Join-Path $StagingRoot 'PolyMon Manager'
$StageMonitors = Join-Path $StagingRoot 'PolyMon Manager\Monitors'
$StageExec     = Join-Path $StagingRoot 'PolyMon Executive'
$StageSql      = Join-Path $StagingRoot 'SQL'

# --- File manifests (from PolyMon.wxs) ---
$ManagerFiles = @(
    'PolyMonManager.exe'
    'PolyMonManager.exe.config'
    'PolyMon.dll'
    'PolyMonNotifier.dll'
    'GenericMonitor.dll'
    'GenericMonitorEditor.dll'
    'GenericXMLEditor.dll'
    'ZedGraph.dll'
    'Interop.MSScriptControl.dll'
    'AlertRecap_Email.xsl'
    'AlertRecap_Web.xsl'
    'Heartbeat_Email.xsl'
    'Notify.wav'
)

# polymon.chm is optional — include if it exists
$ManagerOptional = @('polymon.chm', 'PolyMonLicense.pdf')

$MonitorDlls = @(
    'CPUMonitor.dll'
    'DiskMonitor.dll'
    'FileMonitor.dll'
    'PerfMonitor.dll'
    'PingMonitor.dll'
    'PowerShellMonitor.dll'
    'ServiceMonitor.dll'
    'SNMPMonitor.dll'
    'SNMP.dll'
    'SQLMonitor.dll'
    'TCPPortMonitor.dll'
    'URLMonitor.dll'
    'URLXMLMonitor.dll'
    'WMIMonitor.dll'
    'NRSPortalMonitor.dll'
)

$MonitorEditorDlls = @(
    'CPUMonitorEditor.dll'
    'DiskMonitorEditor.dll'
    'FileMonitorEditor.dll'
    'PerfMonitorEditor.dll'
    'PingMonitorEditor.dll'
    'PowerShellMonitorEditor.dll'
    'ServiceMonitorEditor.dll'
    'SNMPMonitorEditor.dll'
    'TCPPortMonitorEditor.dll'
    'URLMonitorEditor.dll'
    'URLXMLMonitorEditor.dll'
    'WMIMonitorEditor.dll'
)

$ExecutiveFiles = @(
    'PolyMonExecutive.exe'
    'PolyMonExecutive.exe.config'
    'PolyMon.dll'
    'PolyMonNotifier.dll'
    'GenericMonitor.dll'
    'Interop.MSScriptControl.dll'
    'AlertRecap_Email.xsl'
    'AlertRecap_Web.xsl'
    'Heartbeat_Email.xsl'
)

# Executive also gets all monitor DLLs (no editors)
$ExecutiveMonitors = $MonitorDlls

# Ascend DLLs from the WiX manifest — not in current build output
$AscendDlls = @(
    'Ascend.dll'
    'Ascend.Design.dll'
    'Ascend.Resources.dll'
    'Ascend.Windows.Forms.dll'
)

# --- Functions ---
function Copy-FileList {
    param(
        [string[]]$FileList,
        [string]$SourceDir,
        [string]$DestDir,
        [switch]$Optional
    )
    foreach ($file in $FileList) {
        $src = Join-Path $SourceDir $file
        if (Test-Path $src) {
            Copy-Item $src -Destination $DestDir -Force
        }
        elseif (-not $Optional) {
            Write-Warning "MISSING: $src"
        }
    }
}

function Generate-TSExtendSql {
    <#
    .SYNOPSIS
        Generates TSData-Extend.sql that extends TS lookup tables through 2035.
        Uses the same logic as the original DB Version 1.30.sql TS block,
        but with an extended date range and does NOT delete existing rows —
        it uses IF NOT EXISTS checks to insert only missing rows.
    #>
    param([string]$OutPath)

    $sql = @'
-- TSData-Extend.sql
-- Extends PolyMon TS lookup tables (TSDaily, TSWeekly, TSMonthly) through 2035.
-- Safe to run on existing databases: only inserts rows that don't already exist.
-- Generated by Build-PolyMonPackage.ps1

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @StartDT datetime = '2006-01-01 00:00:00'
DECLARE @EndDT   datetime = '2035-12-31 00:00:00'
DECLARE @StartYear int = YEAR(@StartDT)
DECLARE @EndYear   int = YEAR(@EndDT)

-- We need to figure out the next TimespanID for each table
DECLARE @NextDailyID int = ISNULL((SELECT MAX(TimespanID) FROM TSDaily), 0) + 1
DECLARE @NextWeeklyID int = ISNULL((SELECT MAX(TimespanID) FROM TSWeekly), 0) + 1
DECLARE @NextMonthlyID int = ISNULL((SELECT MAX(TimespanID) FROM TSMonthly), 0) + 1

-----------------------------------------------------------------------
-- Daily
-----------------------------------------------------------------------
DECLARE @CurrDate datetime = @StartDT
WHILE @CurrDate < @EndDT
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM TSDaily
        WHERE Year = YEAR(@CurrDate)
          AND Month = MONTH(@CurrDate)
          AND Day = DAY(@CurrDate)
    )
    BEGIN
        INSERT INTO TSDaily (TimespanID, Year, Month, Day, DT)
        VALUES (@NextDailyID, YEAR(@CurrDate), MONTH(@CurrDate), DAY(@CurrDate),
                CAST(CONVERT(varchar(10), @CurrDate, 120) + ' 00:00:00' AS datetime))
        SET @NextDailyID = @NextDailyID + 1
    END
    SET @CurrDate = DATEADD(dd, 1, @CurrDate)
END

PRINT 'TSDaily extended through 2035.'

-----------------------------------------------------------------------
-- Weekly
-----------------------------------------------------------------------
SET DATEFIRST 7  -- Sunday = first day of week

DECLARE @CurrYear int = @StartYear
DECLARE @CurrWeek smallint
DECLARE @LastWeekNum smallint
DECLARE @WeekStart datetime
DECLARE @WeekEnd datetime

WHILE @CurrYear <= @EndYear
BEGIN
    SET @CurrWeek = 1
    SET @LastWeekNum = DATEPART(week, CAST(CAST(@CurrYear AS varchar(4)) + '-12-31' AS datetime))
    SET @WeekStart = CAST(CAST(@CurrYear AS varchar(4)) + '-01-01' AS datetime)

    WHILE @CurrWeek <= @LastWeekNum
    BEGIN
        SET @WeekEnd = DATEADD(day, 7 - DATEPART(dw, @WeekStart), @WeekStart)

        IF @WeekStart < CAST(CAST(@CurrYear AS varchar(4)) + '-01-01' AS datetime)
            SET @WeekStart = CAST(CAST(@CurrYear AS varchar(4)) + '-01-01' AS datetime)
        IF @WeekEnd > CAST(CAST(@CurrYear AS varchar(4)) + '-12-31' AS datetime)
            SET @WeekEnd = CAST(CAST(@CurrYear AS varchar(4)) + '-12-31' AS datetime)

        IF NOT EXISTS (
            SELECT 1 FROM TSWeekly
            WHERE Year = @CurrYear AND WeekOfYear = DATEPART(week, @WeekStart)
        )
        BEGIN
            INSERT INTO TSWeekly (TimespanID, Year, WeekOfYear, StartDT, EndDT)
            VALUES (@NextWeeklyID, @CurrYear, DATEPART(week, @WeekStart), @WeekStart, @WeekEnd)
            SET @NextWeeklyID = @NextWeeklyID + 1
        END

        SET @CurrWeek = @CurrWeek + 1
        SET @WeekStart = DATEADD(day, 1, @WeekEnd)
    END

    SET @CurrYear = @CurrYear + 1
END

PRINT 'TSWeekly extended through 2035.'

-----------------------------------------------------------------------
-- Monthly
-----------------------------------------------------------------------
SET @CurrYear = @StartYear
DECLARE @CurrMonth tinyint
DECLARE @MonthStart datetime
DECLARE @MonthEnd datetime

WHILE @CurrYear <= @EndYear
BEGIN
    SET @CurrMonth = 1
    WHILE @CurrMonth <= 12
    BEGIN
        SET @MonthStart = CAST(CAST(@CurrYear AS varchar(4)) + '-' + CAST(@CurrMonth AS varchar(2)) + '-01' AS datetime)
        SET @MonthEnd = DATEADD(dd, -1, DATEADD(mm, 1, @MonthStart))

        IF NOT EXISTS (
            SELECT 1 FROM TSMonthly
            WHERE Year = @CurrYear AND Month = @CurrMonth
        )
        BEGIN
            INSERT INTO TSMonthly (TimespanID, Year, Month, StartDT, EndDT)
            VALUES (@NextMonthlyID, @CurrYear, @CurrMonth, @MonthStart, @MonthEnd)
            SET @NextMonthlyID = @NextMonthlyID + 1
        END

        SET @CurrMonth = @CurrMonth + 1
        SET @NextMonthlyID = @NextMonthlyID
    END
    SET @CurrYear = @CurrYear + 1
END

PRINT 'TSMonthly extended through 2035.'
PRINT ''
PRINT 'TS table extension complete.'
GO
'@

    Set-Content -Path $OutPath -Value $sql -Encoding UTF8
}

# ============================================================
# Main
# ============================================================

Write-Host ''
Write-Host '===== PolyMon Package Builder =====' -ForegroundColor Cyan
Write-Host ''

# --- Optional build ---
if ($Build) {
    Write-Host 'Building solution (Release)...' -ForegroundColor Yellow

    $msbuild = $null
    # Try VS Build Tools / VS locations
    $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
    if (Test-Path $vsWhere) {
        $installPath = & $vsWhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath 2>$null
        if ($installPath) {
            $candidate = Join-Path $installPath 'MSBuild\Current\Bin\MSBuild.exe'
            if (Test-Path $candidate) { $msbuild = $candidate }
        }
    }
    # Fallback: framework MSBuild
    if (-not $msbuild) {
        $candidate = Join-Path $env:SystemRoot 'Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe'
        if (Test-Path $candidate) { $msbuild = $candidate }
    }

    if (-not $msbuild) {
        Write-Error 'Could not find MSBuild.exe. Install Visual Studio Build Tools or pass -Build:$false.'
        return
    }

    Write-Host "Using MSBuild: $msbuild"
    & $msbuild $SolutionFile /p:Configuration=Release /verbosity:minimal /nologo
    if ($LASTEXITCODE -ne 0) {
        Write-Error 'Build failed.'
        return
    }
    Write-Host 'Build succeeded.' -ForegroundColor Green
    Write-Host ''
}

# --- Verify source directories exist ---
foreach ($dir in @($ManagerBin, $ExecutiveBin)) {
    if (-not (Test-Path $dir)) {
        Write-Error "Build output not found: $dir`nRun a build first, or use -Build."
        return
    }
}

# --- Clean and create staging directories ---
if (Test-Path $StagingRoot) {
    Write-Host "Removing existing staging folder: $StagingRoot"
    Remove-Item $StagingRoot -Recurse -Force
}

foreach ($dir in @($StageManager, $StageMonitors, $StageExec, $StageSql)) {
    New-Item -ItemType Directory -Path $dir -Force | Out-Null
}

# --- Copy Manager files ---
Write-Host 'Copying Manager files...' -ForegroundColor Yellow
Copy-FileList -FileList $ManagerFiles -SourceDir $ManagerBin -DestDir $StageManager
Copy-FileList -FileList $ManagerOptional -SourceDir $ManagerBin -DestDir $StageManager -Optional
Copy-FileList -FileList $AscendDlls -SourceDir $ManagerBin -DestDir $StageManager -Optional

# Check for Ascend DLLs and warn
$missingAscend = @()
foreach ($dll in $AscendDlls) {
    if (-not (Test-Path (Join-Path $StageManager $dll))) {
        $missingAscend += $dll
    }
}
if ($missingAscend.Count -gt 0) {
    Write-Host "  NOTE: Ascend DLLs not found in build output (Manager ran fine without them):" -ForegroundColor DarkYellow
    $missingAscend | ForEach-Object { Write-Host "    - $_" -ForegroundColor DarkYellow }
}

# --- Copy Monitor DLLs + Editors to Manager\Monitors ---
Write-Host 'Copying monitor DLLs (Manager)...' -ForegroundColor Yellow
Copy-FileList -FileList $MonitorDlls -SourceDir $MonitorsDir -DestDir $StageMonitors
Copy-FileList -FileList $MonitorEditorDlls -SourceDir $MonitorsDir -DestDir $StageMonitors

# --- Copy Executive files ---
Write-Host 'Copying Executive files...' -ForegroundColor Yellow
Copy-FileList -FileList $ExecutiveFiles -SourceDir $ExecutiveBin -DestDir $StageExec
Copy-FileList -FileList $ExecutiveMonitors -SourceDir $ExecutiveBin -DestDir $StageExec

# --- Copy SQL scripts ---
Write-Host 'Copying SQL scripts...' -ForegroundColor Yellow

$sqlFiles = @(
    @{ Src = (Join-Path $SqlCreate 'DB Version 1.30.sql'); Name = 'DB Version 1.30.sql' }
    @{ Src = (Join-Path $SqlUpdate 'Update DB 1.00 to 1.10.sql'); Name = 'Update DB 1.00 to 1.10.sql' }
    @{ Src = (Join-Path $SqlUpdate 'Update DB 1.10 to 1.30.sql'); Name = 'Update DB 1.10 to 1.30.sql' }
)

foreach ($sf in $sqlFiles) {
    if (Test-Path $sf.Src) {
        Copy-Item $sf.Src -Destination (Join-Path $StageSql $sf.Name) -Force
    }
    else {
        Write-Warning "SQL script not found: $($sf.Src)"
    }
}

# --- Generate TSData-Extend.sql ---
Write-Host 'Generating TSData-Extend.sql...' -ForegroundColor Yellow
Generate-TSExtendSql -OutPath (Join-Path $StageSql 'TSData-Extend.sql')

# --- Copy installer scripts ---
Write-Host 'Copying installer scripts...' -ForegroundColor Yellow
$installerScripts = @('Install-PolyMon.ps1', 'Uninstall-PolyMon.ps1')
foreach ($script in $installerScripts) {
    $src = Join-Path $RepoRoot $script
    if (Test-Path $src) {
        Copy-Item $src -Destination $StagingRoot -Force
    }
    else {
        Write-Warning "Installer script not found: $src"
    }
}

# --- Strip PDB files and build artifacts ---
Write-Host 'Cleaning build artifacts...' -ForegroundColor Yellow
Get-ChildItem $StagingRoot -Recurse -Include '*.pdb','*.xml','*.application','*.manifest','*.InstallLog','*.InstallState' |
    Remove-Item -Force
# Keep .exe.config files (the above won't match them since they don't end in .xml)

# --- Summary ---
Write-Host ''
Write-Host '===== Package Contents =====' -ForegroundColor Cyan

$managerCount = (Get-ChildItem $StageManager -File).Count
$monitorsCount = (Get-ChildItem $StageMonitors -File).Count
$execCount = (Get-ChildItem $StageExec -File).Count
$sqlCount = (Get-ChildItem $StageSql -File).Count

Write-Host "  PolyMon Manager:     $managerCount files"
Write-Host "  Manager\Monitors:    $monitorsCount files"
Write-Host "  PolyMon Executive:   $execCount files"
Write-Host "  SQL:                 $sqlCount files"
Write-Host ''

# List all files
Get-ChildItem $StagingRoot -Recurse -File | ForEach-Object {
    $rel = $_.FullName.Substring($StagingRoot.Length + 1)
    Write-Host "  $rel"
}

# --- Optional ZIP ---
if ($Zip) {
    Write-Host ''
    Write-Host 'Creating ZIP archive...' -ForegroundColor Yellow
    $zipPath = Join-Path $OutputPath 'PolyMonInstall.zip'
    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }

    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory($StagingRoot, $zipPath)

    $zipSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 1)
    Write-Host "ZIP created: $zipPath ($zipSize MB)" -ForegroundColor Green
}

Write-Host ''
Write-Host 'Package build complete!' -ForegroundColor Green
Write-Host "Staging folder: $StagingRoot" -ForegroundColor Green
Write-Host ''
